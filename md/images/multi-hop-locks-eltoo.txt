@startuml
title Multi-Hop-Locks with Schnorr (eltoo)
participant Alice
participant Bob
participant Carol
participant Dave

    note over Bob,Carol
        Definitions
        Incomplete 2-of-2 MuSig from user i over m: sig(i,m,T) := k + H(R+T,m)*xi
        adaptor_sig(i,m,T) := sig(i,m,t*G) + t
        Combine incomplete signatures from i and j combine: sig(m,T) = sig(i,m,T) + adaptor_sig(j,m,T)
        <=> adaptor_sig(j,m,T) = sig(m,T) - sig(i,m,T)
    end note

== Overview ==
    Alice->Dave : Pays money
    Dave->Alice : Provides proof of payment

== Offer ==
    Dave->Alice : z*G
    note left
        Dave sends a unique public nonce to Alice to enable the payment
    end note

== Setup ==
    Alice->Alice : draw y0, y1, y2 at random
    note left
        Alice sets up tuple (L,y,R) for every user with
        left (L) and right (R) lock and where R - L = y*G
    end note
    Alice->Alice: (z+y2+y1+y0)*G := (z*G)+(y0+y1+y2)*G

== Alice to Bob ==

    note over Alice,Bob
       txFunding is the funding transaction, spendable by muSig(A,B).

       txCommit(i) is the ith commitment transaction, has one input/one
       output, and can spend either txFunding or txCommit(j) provided
       j<i. It's output is a taproot of P="muSig(A,B)" or 
       S="<T+i+1> OP_CLTV DROP <muSig(A,B)> CHECKSIG". It has nLockTime
       set to <T+i>.

       txSettle(i) the the ith settlement transaction, has one input
       (spending txCommit(i)) and outputs for each party's balance and
       any active HTLCs.  It can only spend txCommit(i) after a delay,
       to allow a higher commitment transaction to be published first.
    end note

    Alice->Bob  : y0, (z+y2+y1+y0)*G
    Bob->Bob    : (z+y2+y1)*G := (z+y2+y1+y0)*G - (y0)*G

    Alice->Bob  : sig(A, txSettle(i), reltimelock)
    Alice->Bob  : for each HTLC to Bob, sig(A, txHTLC(n) to Bob, preimage(n), SIGHASH_SINGLE)
    Alice->Bob  : for each HTLC to Alice, sig(A, txHTLC(n) to Bob, timelock=cltv(n), SIGHASH_SINGLE)

    Bob->Alice  : sig(B, txCommit(i)/txFunding, SIGHASH_SINGLE)
    Bob->Alice  : sig(B, taproot/txCommit(i), SIGHASH_SINGLE+NOINPUT)
    Bob->Alice  : sig(B, txSettle(i), reltimelock)
    Bob->Alice  : for each HTLC to Alice, sig(B, txHTLC(n) to Alice, preimage(n), SIGHASH_SINGLE)
    Bob->Alice  : for each HTLC to Bob, sig(B, txHTLC(n) to Alice, timelock=cltv(n), SIGHASH_SINGLE)

    Alice->Bob  : sig(A, txCommit(i)/txFunding, SIGHASH_SINGLE)
    Alice->Bob  : sig(A, taproot/txCommit(i), SIGHASH_SINGLE+NOINPUT)

== Bob to Carol ==

    note over Bob,Carol
        Invariant
        User 0<i,i<n-1 gives sig(i,tx_i+1,T) to user i+1 only if have
        sig(i-1,txi,T-yi*G) from user i-1 AND sig(i+1,tx_i+1,T) from user i+1.
        User i = 0 gives sig(0,tx_1,T) to user 1 if have sig(1,tx_1,T) from
        user 1
    end note

    Alice->Carol: y1
    Bob->Carol  : (z+y2+y1)*G
    Carol->Carol: (z+y2)*G := (z+y2+y1)*G - (y1)*G

    Bob<->Carol : update commitments

== Carol to Dave ==

    Alice->Dave : y2
    Carol->Dave : (z+y2)*G
    Dave->Dave  : z*G := (z+y2)*G - (y2)*G

    Carol<->Dave: update commitments

== Settlement ==

    Dave->Dave  : calculate (z)+(y2)
    Dave->Carol : reveal z+y2

    Carol->Carol: calculate (z+y2)+(y1)
    Carol->Bob  : reveal (z+y2+y1)

    Bob->Bob    : calculate (z+y2+y1)+(y0)
    Bob->Alice  : reveal (z+y2+y1+y0)

    Alice->Alice: z := (z+y2+y1+y0)-(y2)-(y1)-(y0)

    note over Bob,Carol
      Revealing the secret is either done directly over p2p messaging,
      or by completing the adaptor signature for the HTLC.
    end note

@enduml
